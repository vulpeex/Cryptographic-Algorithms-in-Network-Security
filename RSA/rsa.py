# -*- coding: utf-8 -*-
"""RCC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V2GtoppeQz5ic53_QTsuXfEOlmA7y8ca
"""

import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import random
import math
import time

def is_prime(num):
    """Check if a number is prime"""
    if num <= 1:
        return False
    if num <= 3:
        return True
    if num % 2 == 0 or num % 3 == 0:
        return False

    i = 5
    while i * i <= num:
        if num % i == 0 or num % (i + 2) == 0:
            return False
        i += 6
    return True

def generate_prime(bits):
    """Generate a prime number with specified number of bits"""
    while True:
        # Generate a random number with the specified number of bits
        num = random.getrandbits(bits)
        # Ensure the number is odd and has the correct number of bits
        num |= (1 << bits - 1) | 1
        if is_prime(num):
            return num

def gcd(a, b):
    """Calculate greatest common divisor using Euclidean algorithm"""
    while b:
        a, b = b, a % b
    return a

def extended_gcd(a, b):
    """Extended Euclidean Algorithm to find modular multiplicative inverse"""
    if a == 0:
        return b, 0, 1
    else:
        gcd, x, y = extended_gcd(b % a, a)
        return gcd, y - (b // a) * x, x

def mod_inverse(e, phi):
    """Calculate modular multiplicative inverse"""
    gcd, x, y = extended_gcd(e, phi)
    if gcd != 1:
        raise Exception('Modular inverse does not exist')
    else:
        return x % phi

def generate_keypair(bits=16):
    """Generate RSA public and private key pair"""
    # Generate two distinct prime numbers
    p = generate_prime(bits)
    q = generate_prime(bits)
    while p == q:
        q = generate_prime(bits)

    # Calculate n and phi(n)
    n = p * q
    phi = (p - 1) * (q - 1)

    # Choose e such that 1 < e < phi and gcd(e, phi) = 1
    e = 65537  # Common choice for e
    while gcd(e, phi) != 1:
        e = random.randrange(2, phi)

    # Calculate d, the modular multiplicative inverse of e mod phi
    d = mod_inverse(e, phi)

    return (e, n), (d, n)

def rsa_encrypt_block(plaintext_block, public_key):
    """Encrypt a single block using RSA"""
    e, n = public_key
    # Ensure the block is smaller than n
    if plaintext_block >= n:
        raise ValueError(f"Block value {plaintext_block} is too large for n={n}")
    return pow(plaintext_block, e, n)

def rsa_decrypt_block(ciphertext_block, private_key):
    """Decrypt a single block using RSA"""
    d, n = private_key
    return pow(ciphertext_block, d, n)

def image_to_blocks(image_path, block_size):
    """Convert image to blocks of integers"""
    # Open the image
    img = Image.open(image_path)
    img_array = np.array(img)

    # Get image dimensions and channels
    height, width = img_array.shape[:2]
    channels = 1 if len(img_array.shape) == 2 else img_array.shape[2]

    # Flatten the image array
    flat_img = img_array.flatten()

    # Determine how many pixels can fit in one block
    # Each pixel value is between 0-255, so we need log_256(n) pixels per block
    pixels_per_block = block_size // 8  # 8 bits per byte

    # Ensure we have at least 1 pixel per block
    pixels_per_block = max(1, pixels_per_block)

    # Split the flattened image into blocks
    blocks = []
    for i in range(0, len(flat_img), pixels_per_block):
        # Get pixels for this block
        pixel_block = flat_img[i:i+pixels_per_block]

        # Convert pixels to a single integer value
        block_value = 0
        for j, pixel in enumerate(pixel_block):
            block_value += int(pixel) << (j * 8)

        blocks.append(block_value)

    return blocks, height, width, channels

def blocks_to_image(blocks, height, width, channels, pixels_per_block, block_size):
    """Convert blocks of integers back to an image"""
    # Initialize flat image array
    flat_img = np.zeros(height * width * channels, dtype=np.uint8)

    # Process each block
    for i, block in enumerate(blocks):
        # Extract pixels from block
        start_idx = i * pixels_per_block
        for j in range(pixels_per_block):
            if start_idx + j < len(flat_img):
                # Extract the j-th pixel value from the block
                pixel_value = (block >> (j * 8)) & 0xFF
                flat_img[start_idx + j] = pixel_value

    # Reshape flat array back to image dimensions
    if channels == 1:
        img_array = flat_img.reshape((height, width))
    else:
        img_array = flat_img.reshape((height, width, channels))

    # Convert to PIL Image
    img = Image.fromarray(img_array.astype(np.uint8))
    return img

def encrypt_image(image_path, public_key):
    """Encrypt an image using RSA"""
    # Calculate max block size based on n
    _, n = public_key
    block_size = n.bit_length() - 1  # Ensure block is smaller than n

    # Convert image to blocks
    blocks, height, width, channels = image_to_blocks(image_path, block_size)

    # Encrypt each block
    encrypted_blocks = []
    for block in blocks:
        try:
            encrypted_block = rsa_encrypt_block(block, public_key)
            encrypted_blocks.append(encrypted_block)
        except ValueError as e:
            print(f"Error encrypting block: {e}")
            # Use a placeholder value for failed blocks
            encrypted_blocks.append(0)

    # Calculate how many pixels can fit in one block
    pixels_per_block = block_size // 8
    pixels_per_block = max(1, pixels_per_block)

    return encrypted_blocks, height, width, channels, pixels_per_block, block_size

def decrypt_image(encrypted_blocks, height, width, channels, pixels_per_block, block_size, private_key):
    """Decrypt an image using RSA"""
    # Decrypt each block
    decrypted_blocks = []
    for block in encrypted_blocks:
        decrypted_block = rsa_decrypt_block(block, private_key)
        decrypted_blocks.append(decrypted_block)

    # Convert blocks back to image
    img = blocks_to_image(decrypted_blocks, height, width, channels, pixels_per_block, block_size)
    return img

def save_encrypted_data(encrypted_blocks, height, width, channels, pixels_per_block, block_size, filename):
    """Save encrypted data to a file"""
    with open(filename, 'w') as f:
        f.write(f"{height}\n{width}\n{channels}\n{pixels_per_block}\n{block_size}\n")
        for block in encrypted_blocks:
            f.write(f"{block}\n")

def load_encrypted_data(filename):
    """Load encrypted data from a file"""
    with open(filename, 'r') as f:
        lines = f.readlines()

    height = int(lines[0])
    width = int(lines[1])
    channels = int(lines[2])
    pixels_per_block = int(lines[3])
    block_size = int(lines[4])
    encrypted_blocks = [int(line.strip()) for line in lines[5:]]

    return encrypted_blocks, height, width, channels, pixels_per_block, block_size

def main():
    # Image path - replace with your image path
    image_path = "input_02.jpg"

    print("Generating RSA key pair...")
    start_time = time.time()
    public_key, private_key = generate_keypair(bits=24)  # Use smaller bits for testing
    print(f"Key generation took {time.time() - start_time:.2f} seconds")
    print(f"Public key (e, n): {public_key}")
    print(f"Private key (d, n): {private_key}")

    # Encrypt image
    print("Encrypting image...")
    start_time = time.time()
    encrypted_data = encrypt_image(image_path, public_key)
    encrypted_blocks, height, width, channels, pixels_per_block, block_size = encrypted_data
    print(f"Encryption took {time.time() - start_time:.2f} seconds")

    # Save encrypted data
    save_encrypted_data(encrypted_blocks, height, width, channels, pixels_per_block, block_size, "encrypted_image.txt")

    # Create a visualization of the encrypted data
    # This is just for visualization, the actual encrypted data is in encrypted_blocks
    encrypted_img_array = np.zeros((height, width, 3 if channels > 1 else 1), dtype=np.uint8)
    for i in range(min(len(encrypted_blocks), height * width)):
        row = i // width
        col = i % width
        value = encrypted_blocks[i] % 256  # Map to 0-255 range for visualization
        if channels > 1:
            encrypted_img_array[row, col] = [value, value, value]
        else:
            encrypted_img_array[row, col] = value

    # Save encrypted visualization
    plt.figure(figsize=(10, 5))
    plt.subplot(1, 2, 1)
    plt.title("Original Image")
    plt.imshow(np.array(Image.open(image_path)))
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.title("Encrypted Image (Visualization)")
    if channels > 1:
        plt.imshow(encrypted_img_array)
    else:
        plt.imshow(encrypted_img_array.squeeze(), cmap='gray')
    plt.axis('off')
    plt.savefig("encryption_comparison.png")
    plt.close()

    # Decrypt image
    print("Decrypting image...")
    start_time = time.time()
    decrypted_img = decrypt_image(encrypted_blocks, height, width, channels, pixels_per_block, block_size, private_key)
    print(f"Decryption took {time.time() - start_time:.2f} seconds")

    # Save decrypted image
    decrypted_img.save("decrypted_image.jpg")

    # Display results
    plt.figure(figsize=(15, 5))
    plt.subplot(1, 3, 1)
    plt.title("Original Image")
    plt.imshow(np.array(Image.open(image_path)))
    plt.axis('off')

    plt.subplot(1, 3, 2)
    plt.title("Encrypted Image (Visualization)")
    if channels > 1:
        plt.imshow(encrypted_img_array)
    else:
        plt.imshow(encrypted_img_array.squeeze(), cmap='gray')
    plt.axis('off')

    plt.subplot(1, 3, 3)
    plt.title("Decrypted Image")
    plt.imshow(np.array(decrypted_img))
    plt.axis('off')
    plt.savefig("full_comparison.png")
    plt.close()

    print("Process completed! Check the output files.")

if __name__ == "__main__":
    main()